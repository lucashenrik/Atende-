package com.lucas.demo.service;

import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

//import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import com.lucas.demo.exceptions.ErroArquivoException;
import com.lucas.demo.exceptions.ErroProcessamentoException;
import com.lucas.demo.exceptions.ItemNaoEncontradoException;
import com.lucas.demo.model.Item;
import com.lucas.demo.model.ItemXml;
import com.lucas.demo.model.Prefixo;

import jakarta.annotation.PostConstruct;

@Service
public class PedidoServico {

	@Lazy
	@Autowired
	ArquivoService arquivoServ;

	@Autowired
	PrefixosService prefixoServ;
	
	String email = "lucashenrik033@gmail,com";
	
	String token = "ba79ef80-4713-434c-909b-8c6dc51fbe4dd4c9f894450b9b139fc8315617c7637a1317-a9e8-4b9f-8388-d772c4c1c537";

	LocalDate data = LocalDate.now();

	ObjectMapper mapper = new ObjectMapper();

	String diretorio = "C:\\Users\\Lucas\\Documents\\Projetos\\demo\\Registros\\Pedidos";
	String caminhoArq = diretorio + "\\pedidos_" + data + ".json";

	private List<Map<String, String>> pedidoMemoria = Collections.synchronizedList(new ArrayList<>());
	// private List<Map<String, String>> pedidoMemoria = new ArrayList<>();
	int iMemoria;
	List<Map<String, String>> pedidosEmArquivo = new ArrayList<>();
	int iArquivo;

	List<Map<String, String>> pedidosVerficados = new ArrayList<>();

	List<Map<String, String>> pedidosEntregues = new ArrayList<>();

	// List<String> prefixos = Arrays.asList("Jantinha", "Batata", "Porção",
	// "Taboa");

	List<String> prefixosComoString;

	// Mova o carregamento dos prefixos para o método @PostConstruct
	@PostConstruct
	public void init() {
		List<Prefixo> prefixosP = prefixoServ.carregarPrefixos();
		prefixosComoString = prefixosP.stream().map(Prefixo::getPrefixo).collect(Collectors.toList());
	}

	public Item xmlParaPedido(String xml) throws JAXBException {
		// Cria o contexto JAXB para a classe Pedido
		JAXBContext context = JAXBContext.newInstance(Item.class);
		// Cria o Unmarshaller, que transforma o XML em objeto
		Unmarshaller unmarshaller = context.createUnmarshaller();
		// Converte o XML (em String) para um objeto Pedido
		StringReader reader = new StringReader(xml);
		Item item = (Item) unmarshaller.unmarshal(reader);
		return item;
	}

	public String getUrl(String noticacaoCode) {

		String getUrl = "https://ws.pagseguro.uol.com.br/v3/transactions/notifications/" + noticacaoCode +"?email="+ email +"&token=" + token;
 
		return getUrl;
	}

	public String urlProcess(String notificacaoCode) {
		String urlProcess = "http://localhost:8080/pedido/processar-notificacao?notificacaoCode=" + notificacaoCode;
		
		return urlProcess;
	}

	/*
	 * public void processarItens(String json) { ObjectMapper objectMapper = new
	 * ObjectMapper(); List<Item> items = new ArrayList<>();
	 * 
	 * try { JsonNode rootNode = objectMapper.readTree(json); JsonNode itemsNode =
	 * rootNode.path("items");
	 * 
	 * if (!itemsNode.isArray()) { throw new
	 * ErroProcessamentoException("O JSON enviado não contém o campo 'items' ou está malformado."
	 * ); }
	 * 
	 * for (JsonNode itemNode : itemsNode) { Item novoItem =
	 * objectMapper.treeToValue(itemNode, Item.class);
	 * 
	 * if (começaComPrefixo(novoItem.getName())) { Item itemExistente =
	 * encontrarItemNaLista(items, novoItem);
	 * 
	 * if (itemExistente != null) {
	 * itemExistente.setQuantity(itemExistente.getQuantity() +
	 * novoItem.getQuantity()); } else { items.add(novoItem); } } else { //
	 * System.out.println("Item não contém prefixo: " + novoItem.getName()); } }
	 * 
	 * // Exibir e escrever os itens processados for (Item item : items) {
	 * arquivoServ.escreverPedido(item); System.out.println("Item: " + item); }
	 * 
	 * } catch (JsonProcessingException e) { // Captura o erro ao tentar processar o
	 * JSON malformado e lança exceção // personalizada throw new
	 * ErroProcessamentoException("Erro ao processar JSON malformado", e); } }
	 */

	/*
	 * public void processarItens(String xml) { XmlMapper xmlMapper = new
	 * XmlMapper();
	 * 
	 * try { // Converte o XML para uma árvore JSON JsonNode rootNode =
	 * xmlMapper.readTree(xml);
	 * 
	 * // Verifica a existência do campo 'items' JsonNode itemsNode =
	 * rootNode.get("items");
	 * 
	 * if (itemsNode == null) { // Se o campo 'items' não for encontrado, lança
	 * exceção throw new
	 * ErroProcessamentoException("O XML enviado não contém o campo 'items' ou está malformado."
	 * ); } else { // Exibe o conteúdo do campo 'items' (para depuração)
	 * System.out.println("Campo 'items' encontrado: " + itemsNode.toString());
	 * 
	 * // Processar os itens dentro do campo 'items' if (itemsNode != null) {
	 * List<ItemXml> itensProcessados = new ArrayList<>();
	 * 
	 * for (JsonNode itemNode : itemsNode) { // Converte cada nó em um objeto
	 * ItemXml ItemXml novoItem = xmlMapper.treeToValue(itemNode, ItemXml.class);
	 * 
	 * if (começaComPrefixo(novoItem.getName())) { ItemXml itemExistente =
	 * encontrarItemNaLista(itensProcessados, novoItem);
	 * 
	 * if (itemExistente != null) { // Atualiza a quantidade se o item já existir
	 * itemExistente.setQuantity(itemExistente.getQuantity() +
	 * novoItem.getQuantity()); } else { // Adiciona o novo item à lista
	 * itensProcessados.add(novoItem); } } }
	 * 
	 * // Exibe e escreve os itens processados for (ItemXml item : itensProcessados)
	 * { arquivoServ.escreverPedido(item); System.out.println("Item processado: " +
	 * item); } } }
	 * 
	 * } catch (IOException e) { throw new
	 * ErroProcessamentoException("Erro ao ler o XML", e); } catch (Exception e) {
	 * throw new ErroProcessamentoException("Erro ao processar o XML", e); } }
	 */

	public void processarItens(String xml) {
		XmlMapper xmlMapper = new XmlMapper();

		try {
			// Converte o XML para uma árvore JSON
			JsonNode rootNode = xmlMapper.readTree(xml);

			// Verifica a existência do campo 'items'
			JsonNode itemsNode = rootNode.get("items");

			if (itemsNode == null) {
				throw new ErroProcessamentoException("O XML enviado não contém o campo 'items' ou está malformado.");
			} else {
				// System.out.println("Campo 'items' encontrado: " + itemsNode.toString());

				// Processar os itens dentro do campo 'items'
				JsonNode itemArrayNode = itemsNode.get("item"); // Acessa o array de itens

				if (itemArrayNode != null && itemArrayNode.isArray()) { // Verifica se é um array
					List<ItemXml> itensProcessados = new ArrayList<>();

					for (JsonNode itemNode : itemArrayNode) {
						ItemXml novoItem = xmlMapper.treeToValue(itemNode, ItemXml.class);

						// Verifica se o novoItem não é nulo antes de processar
						if (novoItem != null && começaComPrefixo(novoItem.getName())) {
							processarItem(novoItem, itensProcessados);
						}
					}

					// Exibe e escreve os itens processados
					for (ItemXml item : itensProcessados) {
						arquivoServ.escreverPedido(item);
						// System.out.println("Item processado: " + item);
					}
				}
			}

		} catch (IOException e) {
			throw new ErroProcessamentoException("Erro ao ler o XML", e);
		} catch (Exception e) {
			throw new ErroProcessamentoException("Erro ao processar o XML", e);
		}
	}

	// Método auxiliar para processar os itens
	private void processarItem(ItemXml novoItem, List<ItemXml> itensProcessados) {
		if (novoItem != null && começaComPrefixo(novoItem.getName())) {
			ItemXml itemExistente = encontrarItemNaLista(itensProcessados, novoItem);

			if (itemExistente != null) {
				// Atualiza a quantidade se o item já existir
				itemExistente.setQuantity(itemExistente.getQuantity() + novoItem.getQuantity());
			} else {
				// Adiciona o novo item à lista
				itensProcessados.add(novoItem);
			}
		}
	}
	/*
	 * // Método auxiliar para processar os itens private void processarItem(ItemXml
	 * novoItem, List<ItemXml> itensProcessados) { if (novoItem != null &&
	 * começaComPrefixo(novoItem.getName())) { ItemXml itemExistente =
	 * encontrarItemNaLista(itensProcessados, novoItem);
	 * 
	 * if (itemExistente != null) { // Atualiza a quantidade se o item já existir
	 * itemExistente.setQuantity(itemExistente.getQuantity() +
	 * novoItem.getQuantity()); } else { // Adiciona o novo item à lista
	 * itensProcessados.add(novoItem); } } }
	 * 
	 * 
	 * 
	 * // Método para encontrar um item com o mesmo nome e ID de referência na lista
	 * private Item encontrarItemNaLista(List<Item> items, Item novoItem) { for
	 * (Item item : items) { if (item.getName().equals(novoItem.getName())) { return
	 * item; } } return null; }
	 */

	// Método para encontrar um item com o mesmo nome e ID de referência na lista
	private ItemXml encontrarItemNaLista(List<ItemXml> items, ItemXml novoItem) {
		for (ItemXml item : items) {
			if (item.getName().equals(novoItem.getName())) {
				return item;
			}
		}
		return null;
	}

	/*
	 * public void adicionarItem(Item item) { try { int id = item.getReferenceId();
	 * int quantity = item.getQuantity(); String description = item.getName();
	 * 
	 * Map<String, String> novoItem = new HashMap<>(); novoItem.put("reference_id",
	 * String.valueOf(id)); novoItem.put("quantity", String.valueOf(quantity));
	 * novoItem.put("description", description); novoItem.put("status",
	 * "andamento");
	 * 
	 * // pedidoMemoria.add(novoItem);
	 * 
	 * System.out.println("Pedido memoria.size: " + pedidoMemoria.size());
	 * 
	 * } catch (ItemNaoEncontradoException e) { throw new
	 * ItemNaoEncontradoException("Não foi possivel adicionar item. ", e); } }
	 */

	public void adicionarItem(ItemXml item) {
		try {
			int id = item.getReferenceId();
			int quantity = item.getQuantity();
			String description = item.getName();

			Map<String, String> novoItem = new HashMap<>();
			novoItem.put("reference_id", String.valueOf(id));
			novoItem.put("quantity", String.valueOf(quantity));
			novoItem.put("description", description);
			novoItem.put("status", "andamento");

			// pedidoMemoria.add(novoItem);

			System.out.println("Pedido memoria.size: " + pedidoMemoria.size());

		} catch (ItemNaoEncontradoException e) {
			throw new ItemNaoEncontradoException("Não foi possivel adicionar item. ", e);
		}
	}

	/*
	 * public synchronized void carregarPedidos() {
	 * 
	 * // Limpa a lista antes de carregar os pedidos pedidosVerficados.clear();
	 * 
	 * try { File arquivo = new File(caminhoArq);
	 * 
	 * if (pedidoMemoria.size() < pedidosEmArquivo.size() ||
	 * pedidoMemoria.isEmpty()) { if (arquivo.exists()) { try { pedidosEmArquivo =
	 * mapper.readValue(arquivo, new TypeReference<List<Map<String, String>>>() {
	 * });
	 * 
	 * for (Map<String, String> item : pedidosEmArquivo) { String statusItem =
	 * item.get("status"); if ("entregue".equals(statusItem)) { // if
	 * (statusItem.equals("entregue")) { pedidosEntregues.add(item); } else {
	 * pedidosVerficados.add(item); pedidoMemoria.add(item); } }
	 * 
	 * int quantidadeNoArquivo = pedidosEmArquivo.size();
	 * System.out.println("Quantidade de pedidos no arquivo: " +
	 * quantidadeNoArquivo); //
	 * System.out.println("Pedidos carregados com sucesso do arquivo."); } catch
	 * (IOException e) { //
	 * System.out.println("Falha ao carregar pedidos do arquivo: " + throw new
	 * ErroArquivoException("Falha ao carregar pedidos do arquivo: ", e); } } } }
	 * catch (ErroArquivoException e) { throw new ErroArquivoException("Arquivo " +
	 * caminhoArq + " não encontrado."); } System.out.println("Items nao entregues"
	 * + pedidosVerficados); System.out.println("Items entregues: " +
	 * pedidosEntregues); // System.out.println("Items nao entregues" +
	 * pedidosEmArquivo); }
	 */

	/*
	 * public synchronized void carregarPedidos() { // Limpa as listas de pedidos
	 * verificados e entregues pedidosVerficados.clear(); pedidosEntregues.clear();
	 * 
	 * try { File arquivo = new File(caminhoArq);
	 * 
	 * // Verifica se o arquivo existe if (arquivo.exists()) { try { // Carrega os
	 * pedidos do arquivo pedidosEmArquivo = mapper.readValue(arquivo, new
	 * TypeReference<List<Map<String, String>>>() {});
	 * 
	 * // Exibe os pedidos lidos do arquivo
	 * System.out.println("Pedidos lidos do arquivo: " + pedidosEmArquivo);
	 * 
	 * // Processa os pedidos for (Map<String, String> item : pedidosEmArquivo) {
	 * String statusItem = item.get("status");
	 * 
	 * if ("entregue".equals(statusItem)) { // Adiciona à lista de pedidos entregues
	 * pedidosEntregues.add(item); } else { // Adiciona todos os pedidos não
	 * entregues diretamente pedidosVerficados.add(item); } }
	 * 
	 * // Exibe a quantidade de pedidos carregados do arquivo int
	 * quantidadeNoArquivo = pedidosEmArquivo.size();
	 * System.out.println("Quantidade de pedidos no arquivo: " +
	 * quantidadeNoArquivo); } catch (IOException e) { throw new
	 * ErroArquivoException("Falha ao carregar pedidos do arquivo: ", e); } } }
	 * catch (ErroArquivoException e) { throw new ErroArquivoException("Arquivo " +
	 * caminhoArq + " não encontrado."); }
	 * 
	 * // Exibe os pedidos System.out.println("Pedidos não entregues: " +
	 * pedidosVerficados); System.out.println("Pedidos entregues: " +
	 * pedidosEntregues); }
	 */

	// ignora pedidos com ids iguais
	/*
	 * public synchronized void carregarPedidos() {
	 * 
	 * try { File arquivo = new File(caminhoArq);
	 * 
	 * // Carrega os pedidos do arquivo apenas se houver novos pedidos ou se a
	 * memória estiver vazia if (pedidoMemoria.isEmpty() || pedidoMemoria.size() <
	 * pedidosEmArquivo.size()) { if (arquivo.exists()) { try { // Ler pedidos do
	 * arquivo pedidosEmArquivo = mapper.readValue(arquivo, new
	 * TypeReference<List<Map<String, String>>>() { });
	 * 
	 * // Atualiza as listas de pedidos, sem limpar toda a memória for (Map<String,
	 * String> item : pedidosEmArquivo) { String statusItem = item.get("status");
	 * 
	 * if ("entregue".equals(statusItem)) { // Adiciona apenas se ainda não estiver
	 * na lista de entregues if (!pedidosEntregues.contains(item)) {
	 * pedidosEntregues.add(item); } } else { // Adiciona apenas se ainda não
	 * estiver na lista de não entregues if (!pedidosVerficados.contains(item)) {
	 * pedidosVerficados.add(item); pedidoMemoria.add(item); // Cache em memória } }
	 * }
	 * 
	 * int quantidadeNoArquivo = pedidosEmArquivo.size();
	 * System.out.println("Quantidade de pedidos no arquivo: " +
	 * quantidadeNoArquivo);
	 * 
	 * } catch (IOException e) { throw new
	 * ErroArquivoException("Falha ao carregar pedidos do arquivo: ", e); } } } else
	 * { // Utiliza a memória caso não haja novos pedidos
	 * System.out.println("Usando pedidos armazenados em memória."); } } catch
	 * (ErroArquivoException e) { throw new ErroArquivoException("Arquivo " +
	 * caminhoArq + " não encontrado."); }
	 * 
	 * // Exibir resultados System.out.println("Items nao entregues: " +
	 * pedidosVerficados); System.out.println("Items entregues: " +
	 * pedidosEntregues); }
	 */

	public synchronized void carregarPedidos() {
		try {
			File arquivo = new File(caminhoArq);

			// Carrega os pedidos do arquivo ou se a memória estiver vazia
			if (pedidoMemoria.isEmpty() || pedidoMemoria.size() < pedidosEmArquivo.size()) {
				if (arquivo.exists()) {
					try {
						// Ler pedidos do arquivo
						pedidosEmArquivo = mapper.readValue(arquivo, new TypeReference<List<Map<String, String>>>() {
						});

						// Atualiza as listas de pedidos
						for (Map<String, String> item : pedidosEmArquivo) {
							String statusItem = item.get("status");

							if ("entregue".equals(statusItem)) {
								// Adiciona todos os pedidos entregues, mesmo com IDs repetidos
								pedidosEntregues.add(item);
							} else {
								// Adiciona todos os pedidos não entregues, mesmo com IDs repetidos
								pedidosVerficados.add(item);
								pedidoMemoria.add(item); // Adiciona todos à memória
							}
						}

						int quantidadeNoArquivo = pedidosEmArquivo.size();
						System.out.println("Quantidade de pedidos no arquivo: " + quantidadeNoArquivo);

					} catch (IOException e) {
						throw new ErroArquivoException("Falha ao carregar pedidos do arquivo: ", e);
					}
				}
			} else {
				// Utiliza a memória caso não haja novos pedidos
				System.out.println("Usando pedidos armazenados em memória.");
			}
		} catch (ErroArquivoException e) {
			throw new ErroArquivoException("Arquivo " + caminhoArq + " não encontrado.");
		}

		// Exibir resultados, sem ignorar itens repetidos
		System.out.println("Pedidos nao entregues: " + pedidosVerficados);
		System.out.println("Pedidos entregues: " + pedidosEntregues);
	}

	public List<String> contar() {

		try {

			// Mapa para armazenar o nome do item e a quantidade correspondente
			Map<String, Integer> contagemItems = new HashMap<>();

			List<String> listaContagem = new ArrayList<>();

			// carregarPedidos();

			// Percorre a lista de pedidos e conta a quantidade de cada item
			for (Map<String, String> item : pedidosVerficados) {
				String nomeItem = item.get("description");

				if (nomeItem != null) {
					String quantityString = item.get("quantity");
					int quantity = Integer.parseInt(quantityString);
					// Verifica se o item já foi contado, se sim, incrementa, senão adiciona
					contagemItems.put(nomeItem, contagemItems.getOrDefault(nomeItem, 0) + quantity);
				}
			}

			// Exibe o resultado final no formato desejado
			for (Map.Entry<String, Integer> entry : contagemItems.entrySet()) {

				String nomeItem = entry.getKey();
				int quantidade = entry.getValue();
				String result = nomeItem + ": " + quantidade;
				listaContagem.add(result);
			}

			return listaContagem;
		} catch (Exception e) {
			throw new ErroArquivoException("Erro inesperado ao tentar ler pedidos.", e.getCause());
		}
	}

	public List<Map<String, String>> getPedidoList() {
		// if (pedidosEmArquivo == null /*|| pedidosEmArquivo.isEmpty()*/) {
		return pedidosVerficados;
		// } else {
		// throw new ErroArquivoException("Nenhum pedido encontrado no arquivo.");
		// }
	}

	public List<Map<String, String>> getPedidosEntregues() {
		return pedidosEntregues;
	}

	private boolean começaComPrefixo(String descricao) {
		return descricao != null && prefixosComoString.stream().anyMatch(descricao::startsWith);
	}

	/*
	 * private boolean começaComPrefixo(String descricao) { return
	 * prefixosComoString.stream().anyMatch(descricao::startsWith); }
	 */

	/*
	 * private boolean começaComPrefixo(String descricao) { return
	 * prefixos.stream().anyMatch(descricao::startsWith); }
	 */
}