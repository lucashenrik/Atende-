package com.lucas.demo.infra;

import java.io.IOException;
import java.security.Key;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.ServletException;

public class JwtFilter implements Filter {

	private static final String AUTH_HEADER = "Authorization";
	private static final String BEARER_PREFIX = "Bearer ";
	private static final String SECRET_KEY = "your-secret-key-here"; // Use a secure key management approach

	private Key key;

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		key = Keys.hmacShaKeyFor(SECRET_KEY.getBytes()); // Gera uma chave segura a partir da chave secreta
	}

	  @Override
	    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
	            throws IOException, ServletException {
			 HttpServletRequest httpRequest = (HttpServletRequest) request;
		        HttpServletResponse httpResponse = (HttpServletResponse) response;
		        
		        String authHeader = httpRequest.getHeader(AUTH_HEADER);
		        
		        if(authHeader != null && authHeader.startsWith(BEARER_PREFIX)) {
		        	String token = authHeader.substring(BEARER_PREFIX.length());
		        	
		        	try {
						Claims claims = Jwts.parserBuilder()
								.setSigningKey(key)
								.build()
								.parseClaimsJws(token)
								.getBody();
						
						// Adiciona as informações do usuário ao contexto de segurança
		                httpRequest.setAttribute("claims", claims);
		                
					} catch (Exception e) {
						// TODO: handle exception
					}
		        }
		}
	}

