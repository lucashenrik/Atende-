package com.lucas.demo.service;

import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.lucas.demo.model.Item;

@Service
public class PedidoServico {

	@Lazy
	@Autowired
	ArquivoService arquivoServ;

	LocalDate data = LocalDate.now();
	ObjectMapper mapper = new ObjectMapper();
	String diretorio = "C:\\Users\\Lucas\\Documents\\Projetos\\demo\\Registros\\Pedidos";
	String caminhoArq = diretorio + "\\pedidos_" + data + ".json";

	private List<Map<String, String>> pedidoMemoria = new ArrayList<>();
	int iMemoria;

	List<Map<String, String>> pedidosEmArquivo = new ArrayList<>();

	List<String> prefixos = Arrays.asList("Jantinha", "Batata", "Porção", "Taboa");

	int iArquivo;

	public Item xmlParaPedido(String xml) throws JAXBException {
		// Cria o contexto JAXB para a classe Pedido
		JAXBContext context = JAXBContext.newInstance(Item.class);
		// Cria o Unmarshaller, que transforma o XML em objeto
		Unmarshaller unmarshaller = context.createUnmarshaller();
		// Converte o XML (em String) para um objeto Pedido
		StringReader reader = new StringReader(xml);
		Item item = (Item) unmarshaller.unmarshal(reader);
		return item;
	}

	public String urlGet(String noticacaoCode) {

		String urlGet = "https://ws.pagseguro.uol.com.br/v3/transactions/notifications/" + noticacaoCode
				+ "?{{credenciais}}";

		return urlGet;
	}

	public String urlProcess(String notificacaoCode) {
		String urlProcess = "http://localhost:8080/pedido/processar-notificacao?notificacaoCode=" + notificacaoCode;

		return urlProcess;
	}

	/*
	 * public void processarItens(String json) { ObjectMapper objectMapper = new
	 * ObjectMapper();
	 * 
	 * 
	 * try { JsonNode rootNode = objectMapper.readTree(json); JsonNode itemsNode =
	 * rootNode.path("items");
	 * 
	 * if (itemsNode.isArray()) { List<Item> items = new ArrayList<>();
	 * 
	 * for (JsonNode itemNode : itemsNode) { Item novoItem =
	 * objectMapper.treeToValue(itemNode, Item.class);
	 * 
	 * if (começaComPrefixo(novoItem.getName())) { items.add(novoItem); // Exibir os
	 * itens for (Item item : items) { arquivoServ.escreverPedido(item); //
	 * System.out.println("Item: " + item); } // System.out.println("tamanho: " +
	 * pedidoMemoria.size()); }else { System.out.println("Nao eh comida"); }
	 * 
	 * }
	 * 
	 * } } catch (IOException e) { e.printStackTrace(); } }
	 */

	public void processarItens(String json) {
		ObjectMapper objectMapper = new ObjectMapper();

		List<Item> items = new ArrayList<>();

		try {
			JsonNode rootNode = objectMapper.readTree(json);
			JsonNode itemsNode = rootNode.path("items");

			if (itemsNode.isArray()) {
				List<Item> itemsTemp = new ArrayList<>();

				for (JsonNode itemNode : itemsNode) {
					Item novoItem = objectMapper.treeToValue(itemNode, Item.class);

					// Verificar se o item começa com um dos prefixos
					if (começaComPrefixo(novoItem.getName())) {

						Item itemExistente = encontrarItemNaLista(itemsTemp, novoItem);

						if (itemExistente != null) {
							// Se o item já existir, aumentar a quantidade
							itemExistente.setQuantity(itemExistente.getQuantity() + novoItem.getQuantity());
							items.add(itemExistente);
						} else {
							items.add(novoItem);
						}

						//itemsTemp.add(novoItem);
						
						// Exibir os itens
						for (Item item : items) {
							arquivoServ.escreverPedido(item);
							System.out.println("Item: " + item);
						}
						// System.out.println("tamanho: " + pedidoMemoria.size());
					} else {
						System.out.println("Nao eh comida");
					}

				}

			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private Item encontrarItemNaLista(List<Item> itemsTemp, Item novoItem) {
		for (Item item : itemsTemp) {
			// && (item.getReferenceId().equals(novoItem.getReferenceId())))
			if (item.getName().equals(novoItem.getName())) {
				return item;
			}
		}
		return null;
	}

	public void adicionarPedido(Item item) {
		int id = item.getReferenceId();
		int quantity = item.getQuantity();
		String description = item.getName();

		Map<String, String> novoItem = new HashMap<>();
		novoItem.put("reference_id", String.valueOf(id));
		novoItem.put("quantity", String.valueOf(quantity));
		novoItem.put("description", description);
		novoItem.put("status", "andamento");

		pedidoMemoria.add(novoItem);

		System.out.println("Pedido memoria.size: " + pedidoMemoria.size());
	}

	public void carregarPedidos() {
		File arquivo = new File(caminhoArq);
		// System.out.println("Verificando se o arquivo existe...");

		if (pedidoMemoria.size() < pedidosEmArquivo.size() || pedidoMemoria.isEmpty() || pedidoMemoria == null) {
			if (arquivo.exists()) {
				try {
					pedidosEmArquivo = mapper.readValue(arquivo, new TypeReference<List<Map<String, String>>>() {
					});
					int quantidadeNoArquivo = pedidosEmArquivo.size();
					System.out.println("Quantidade de pedidos no arquivo: " + quantidadeNoArquivo);
					// System.out.println("Pedidos carregados com sucesso do arquivo.");
				} catch (Exception e) {
					// System.out.println("Falha ao carregar pedidos do arquivo: " +
					// e.getMessage());
					e.printStackTrace();
				}
			} else {
				System.out.println("Arquivo de pedidos não encontrado.");
			}
		} else {
			// System.out.println("Pedidos já carregados na memória.");
		}
	}

	public List<Map<String, String>> getPedidoList() {
		// if (pedidosEmArquivo == null || pedidosEmArquivo.isEmpty()) {
		// System.out.println("Nenhum pedido encontrado no arquivo.");
		// return pedidosEmArquivo;
		// }
		return pedidosEmArquivo;
	}

	private boolean começaComPrefixo(String descricao) {
		return prefixos.stream().anyMatch(descricao::startsWith);
	}
}